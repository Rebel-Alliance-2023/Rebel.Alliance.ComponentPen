@page "/themeswitcher"

@using ComponentPenWASM.Services
@using Microsoft.AspNetCore.Components.QuickGrid
@using ComponentPenWASM
@using System.Linq
@inject RebelThemeService ThemeService

<h3>Theme Switcher</h3>

<div class="controls">
    <div class="mode-toggle">
        <label>
            <input type="checkbox" @bind="isDarkMode" @bind:after="OnThemeModeChanged" />
            Dark Mode
        </label>
    </div>

    <div class="search-box">
        <input type="text" @bind-value="searchTerm" @bind-value:event="oninput" @onkeyup="FilterThemes" placeholder="Search themes..." />
    </div>
</div>

<QuickGrid Items="@filteredThemes" Pagination="@pagination" Class="theme-grid">
    <PropertyColumn Property="@(t => t.Id)" Title="ID" />
    <PropertyColumn Property="@(t => t.Title)" Title="Theme" />
    <TemplateColumn Title="Preview">
        <svg width="100" height="50">
            <rect width="100" height="50" style="@($"fill:url(#gradient{context.Id})")" />
            <defs>
                <linearGradient id="@($"gradient{context.Id}")" x1="0%" y1="0%" x2="100%" y2="0%">
                    @foreach (var stop in ParseGradient(isDarkMode ? context.DarkModeGradient : context.LightModeGradient))
                    {
                        <stop offset="@stop.Offset" stop-color="@stop.Color" />
                    }
                </linearGradient>
            </defs>
        </svg>
    </TemplateColumn>
    <TemplateColumn>
        <button class="btn btn-primary" @onclick="@(() => SelectTheme(context))">Select</button>
    </TemplateColumn>
</QuickGrid>

<Paginator State="@pagination" />

<div class="selected-theme">
    @if (selectedTheme != null)
    {
        <p>Selected Theme: @selectedTheme.Title (@(isDarkMode ? "Dark Mode" : "Light Mode"))</p>
    }
</div>

@code {
    private List<GradientTheme> allThemes = new List<GradientTheme>();
    private IQueryable<GradientTheme> filteredThemes = Enumerable.Empty<GradientTheme>().AsQueryable();
    private GradientTheme? selectedTheme;
    private bool isDarkMode = false;
    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    private string searchTerm = "";

    [Parameter]
    public EventCallback<(GradientTheme, bool)> OnThemeChanged { get; set; }

    protected override void OnInitialized()
    {
        allThemes = GradientThemes.AllThemes;
        FilterThemes();
    }

    private void FilterThemes()
    {
        filteredThemes = allThemes
            .Where(t => t.Title.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
            .AsQueryable();

        // Use reflection to set the read-only property
        var totalItemCountProperty = typeof(PaginationState).GetProperty("TotalItemCount");
        if (totalItemCountProperty != null && totalItemCountProperty.CanWrite)
        {
            totalItemCountProperty.SetValue(pagination, filteredThemes.Count());
        }

        StateHasChanged();
    }

    private async Task SelectTheme(GradientTheme theme)
    {
        selectedTheme = theme;
        ThemeService.SetTheme(theme, isDarkMode);
        await OnThemeChanged.InvokeAsync((theme, isDarkMode));
    }

    private async Task OnThemeModeChanged()
    {
        if (selectedTheme != null)
        {
            ThemeService.SetTheme(selectedTheme, isDarkMode);
            await OnThemeChanged.InvokeAsync((selectedTheme, isDarkMode));
        }
    }

    private class GradientStop
    {
        public string Offset { get; set; } = string.Empty;
        public string Color { get; set; } = string.Empty;
    }

    private List<GradientStop> ParseGradient(string gradientString)
    {
        var stops = new List<GradientStop>();
        var gradientParts = gradientString.Replace("linear-gradient(", "").TrimEnd(')').Split(',');

        for (int i = 0; i < gradientParts.Length; i++)
        {
            var part = gradientParts[i].Trim();
            var colorAndOffset = part.Split(' ');

            if (colorAndOffset.Length >= 2)
            {
                stops.Add(new GradientStop
                {
                    Color = colorAndOffset[0],
                    Offset = colorAndOffset[1]
                });
            }
            else if (i > 0) // If there's no explicit offset, use the previous stop's offset
            {
                stops.Add(new GradientStop
                {
                    Color = colorAndOffset[0],
                    Offset = stops[i - 1].Offset
                });
            }
        }

        return stops;
    }
}

<style>
    .controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
    }

    .search-box input {
        padding: 5px;
        width: 200px;
    }

    .theme-grid {
        width: 100%;
        border-collapse: collapse;
    }

    .theme-grid th, .theme-grid td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }

    .theme-grid th {
        background-color: #f2f2f2;
    }

    .selected-theme {
        margin-top: 20px;
        font-weight: bold;
    }

    .mode-toggle {
        margin-bottom: 20px;
    }
</style>